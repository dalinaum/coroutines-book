# 2장 코틀린 기본 문법

## 2.1 엔트리 포인트

### 코드 2-1: main의 args (args.kt)

`main` 함수는 `args`인자를 받을 수 있다. 이를 활용해보자.

<div class="kotlin-playground" args="코틀린 코루틴 화이팅!">
fun main(args: Array&lt;String&gt;) {
    println("Hello World ${args[0]}")
}
</div>

자신의 컴퓨터에서 실행할 때는 args를 다음과 같이 전달해야 한다.

```sh
kotlinc args.kt -include-runtime -d args.jar
java -jar args.jar 코틀린 코루틴 파이팅
```

## 2.2 함수

### 코드 2-2: 반환 값이 있는 함수 (increment.kt)

함수는 `fun 함수이름(파라미터 리스트): 리턴 타입` 이런 형태로 정의한다.

<div class="kotlin-playground">
fun main() {
    println(increment(3))
}

fun increment(n: Int): Int{
    return n + 1
}
</div>

### 코드 2-3: 표현식 바디 (expression-body.kt)

함수의 바디는 표현식 바디(expression body)로 변경 가능하다.

<div class="kotlin-playground">
fun main() {
    println(increment(3))
}

fun increment(n: Int): Int = n + 1
</div>

### 코드 2-4 반환 타입이 없는 표현식 바디 (expression-body2.kt)

표현식 바디를 쓰는 경우에는 반환 타입이 추론 가능하고 생략할 수 있다.

<div class="kotlin-playground">
fun main() {
    println(increment(3))
}

fun increment(n: Int) = n + 1
</div>

### 코드 2-5 파라미터 두 개 함수 (times.kt)

여러 파라미터를 사용하는 방법은 간단하다. 파라미터 리스트에 파라미터를 여러개를 넣어보자.

<div class="kotlin-playground">
fun main() {
    println(times(3, 4))
}

fun times(a: Int, b: Int) = a * b
</div>

### 코드 2-6 함수를 인자로 전달 (function-arg.kt)

함수를 파라미터로 쓸 때는 `(파라미터 타입들) -> 반환 값`을 타입으로 지정한다.

함수를 전달할 때는 함수 참조 `::`를 함수명 앞에 붙여준다.

<div class="kotlin-playground">
fun main() {
    println(double(6, ::times))
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}

fun times(a: Int, b: Int) = a * b
</div>

## 2.3 람다

### 코드 2-7 람다 버전의 times (lambda.kt)

람다는 중괄호 다음에 파라미터 리스트를 적고 오른쪽에 ->를 입력한다.

<div class="kotlin-playground">
fun main() {
    val times: (Int, Int) -> Int = { a, b ->
        a * b
    }
    println(double(6, times))
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}
</div>

### 코드 2-8 람다 버전의 times 2 (lambda2.kt)

람다는 중괄호 다음에 파라미터 리스트를 적고 오른쪽에 ->를 입력한다.

<div class="kotlin-playground">
fun main() {
    val times = { a: Int, b: Int ->
        a * b
    }
    println(double(6, times))
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}
</div>

### 코드 2-9 람다를 함수 파라미터 (lambda3.kt)

람다를 파라미터에 직접 전달하자.

<div class="kotlin-playground">
fun main() {
    println(
        double(6, { a: Int, b: Int ->
            a * b
        })
    )
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}
</div>

### 코드 2-10 후행 람다 (trailing-lambda.kt)

마지막 파라미터가 람다인 경우 괄호 밖으로 람다를 뺼 수 있다.

<div class="kotlin-playground">
fun main() {
    println(
        double(6) { a: Int, b: Int ->
            a * b
        }
    )
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}
</div>

### 코드 2-11 람다를 반환 (hello-lambda.kt)

반환 값으로 람다를 리턴할 수 있다.

<div class="kotlin-playground">
fun main() {
    println(hello()("코틀린"))
}

fun hello(): (String) -> String {
    return { name ->
        "Hello $name"
    }
}
</div>

### 코드 2-12 클로저 (closure.kt)

람다는 호출 측의 데이터를 참조할 수 있다.

<div class="kotlin-playground">
fun main() {
    println(say("안녕")("코틀린"))
}

fun say(greeting: String): (String) -> String {
    return { name ->
        "$greeting $name"
    }
}
</div>

### 코드 2-13 파라미터 기본 값 (default-value.kt)

파라미터의 기본 값을 지정할 수 있다. "안녕"을 출력할 가능성이 높아 기본값으로 지정해보자.

<div class="kotlin-playground">
fun main() {
    println(say()("코틀린"))
}

fun say(greeting: String = "안녕"): (String) -> String {
    return { name ->
        "$greeting $name"
    }
}
</div>

### 코드 2-14 파라미터를 일부만 지정 (partial-parameter.kt)

add의 파라미터 a, b는 기본 값을 가지고 있고 파라미터를 하나만 전달하면 a에 먼저 적용된다.

<div class="kotlin-playground">
fun main() {
    println(add(1))
}

fun add(a: Int = 2, b: Int = 1) = a + b
</div>

### 코드 2-15 지명 인자 (named-argument.kt)

특정 파라미터를 사용하고 싶다면 호출 할 때 "파라미터 이름 = 값"의 형태로 호출한다.

<div class="kotlin-playground">
fun main() {
    println(add(b = 5))
}

fun add(a: Int = 2, b: Int = 1) = a + b
</div>

## 2.4 변수

### 코드 2-16 변수 (var.kt)

값을 변경하고 싶은 경우 var 변수를 사용한다.

<div class="kotlin-playground">
fun main() {
    var counter = 123
    counter += 1
    var one: Int = 1
    var two: Int? = 2
    println("counter: $counter, one: $one, two: $two")
}
</div>

## 2.5 클래스

### 코드 2-17 클래스 정의 (def-class.kt)

첫번째 클래스를 만들어 보자.

<div class="kotlin-playground">
fun main() {
    val porsche = Car()
    println(porsche)
}

class Car
</div>

### 코드 2-18 생성자와 프로퍼티 (constructor.kt)

클래스 이름 뒤에 파러미터 리스트를 붙이면 생성자가 된다.

클래스 생성자에서 var, val을 붙이면 해당 파라미터의 이름과 같은 프로퍼티가 만들어지고 대입된다.

<div class="kotlin-playground">

fun main() {
    val porsche = Car("Porsche")
    println("자동차의 제조사는: ${porsche.manufacturer}이다")
}

class Car(val manufacturer: String)
</div>

### 코드 2-19 바디 안의 생성자 (secondary-constructor.kt)

클래스 바디 안에 constructor 키워드로 생성자를 만들 수 있다.

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("자동차의 제조사는: ${porsche.manufacturer}이다")
}

class Car {
    constructor(manufacturer: String) {
        this.manufacturer = manufacturer
    }

    val manufacturer: String
}
</div>

### 코드 2-20 주 생성자와 부 생성자 (constructors.kt)

주 생성자와 부 생성자를 쓸 수 있다. 부 생성자는 콜론(:)뒤에 주 생성자 위임(delegation)을 넣는다.

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("제조사는 ${porsche.manufacturer}, ${porsche.cylinders}기통이다")
}

class Car(val manufacturer: String, val cylinders: Int) {
    constructor(manufacturer: String): this(manufacturer, 4) {}
}
</div>

### 코드 2-21 init 블록 (init.kt)

주 생성자가 해야할 일을 `init` 블록에 넣을 수 있다.

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("제조사는 ${porsche.manufacturer}, ${porsche.cylinders}기통이다")
}

class Car(val manufacturer: String, val cylinders: Int) {
    init {
        println("주 생성자: $manufacturer, 실린더: $cylinders")
    }
    constructor(manufacturer: String): this(manufacturer, 4) {
        println("부 생성자: $manufacturer")
    }
}
</div>

### 코드 2-22 init 없는 코드 (wo-init.kt)

`init`을 쓰지 않고 생성자도 명시적으로 바디에 넣은 코드

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("제조사는 ${porsche.manufacturer}, ${porsche.cylinders}기통이다")
}

class Car {
    val manufacturer: String
    val cylinders: Int
    constructor(manufacturer: String, cylinders: Int) {
        this.manufacturer = manufacturer
        this.cylinders = cylinders
        println("주 생성자: $manufacturer, 실린더: $cylinders")
    }
    constructor(manufacturer: String): this(manufacturer, 4) {
        println("부 생성자: $manufacturer")
    }
}
</div>

### 코드 2-23 init이 여럿인 코드 (inits.kt)

`init` 블록이 여럿일 수 있다.

주 생성자가 불러질 때 `init`이 순서대로 여럿 호출된다.

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("제조사는 ${porsche.manufacturer}, ${porsche.cylinders}기통이다")
}

class Car(val manufacturer: String, val cylinders: Int) {
    init {
        println("첫 번째 init: $manufacturer, 실린더: $cylinders")
    }
    constructor(manufacturer: String): this(manufacturer, 4) {
        println("부 생성자: $manufacturer")
    }
    init {
        println("두 번째 init: $manufacturer, 실린더: $cylinders")
    }
}
</div>

### 코드 2-24 간단한 프로퍼티 (property.kt)

클래스 내에서 변수를 선언하듯 간단히 프로퍼티를 만들 수 있다.

`counter`라는 프로퍼티를 만들었다.

<div class="kotlin-playground">
fun main() {
    val holder = CounteHolder()
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
}

class CounteHolder() {
    var counter = 0
}
</div>

### 코드 2-25 프로퍼티 세터 (propoerty-setter.kt)

`set(value)`로 프로퍼티에 세터를 설정할 수 있다. 게터는 자동으로 생성된 것을 사용한다.

<div class="kotlin-playground">
fun main() {
    val holder = CounteHolder()
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
}

class CounteHolder() {
    var counter = 0
        set(value) {
            field = value * 2
        }
}
</div>

### 코드 2-26 프로퍼티 게터 (property-getter.kt)

`get()`로 프로퍼티에 게터를 설정할 수 있다. 세터는 자동으로 생성된 것을 사용한다.

<div class="kotlin-playground">
fun main() {
    val holder = CounteHolder()
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
}

class CounteHolder() {
    var counter = 0
        get() {
           return field + 1  
        }
}
</div>

### 코드 2-27 뒷받침하는 프로퍼티 (backing-property.kt)

프로퍼티가 직접 필드를 가지지 않고 다른 프로퍼티에 의존하는 방법이다.

`list` 프로퍼티가 `var`인 경우에는 세터까지 설정해야 한다.

<div class="kotlin-playground">
fun main() {
    val holder = ListHolder()
    println("list: ${holder.list}")
    holder.addItem("Kotlin")
    println("list: ${holder.list}")
}

class ListHolder() {
    private var _list: MutableList&lt;String&gt;? = null

    val list: List&lt;String&gt;
        get() {
           if (_list == null) {
                _list = mutableListOf("Hello", "World")
           }
           return _list ?: throw AssertionError("다른 스레드가 변경하였습니다")
        }

    fun addItem(item: String) {
        _list?.add(item)
    }
}
</div>

### 코드 2-28 위임된 프로퍼티 lazy (lazy.kt)

`lazy`를 이용해 위임하면 늦게 초기화를 할 수 있음.

<div class="kotlin-playground">
fun main() {
    println("계산 전")
    val holder = LazyHolder()
    println("계산된 결과: ${holder.computedValue}")
    println("첫 번째 리턴")
    println("계산된 결과: ${holder.computedValue}")
    println("두 번째 리턴")
}

class LazyHolder() {
    val computedValue by lazy {
        println("열심히 계산 중!")
        "안녕하세요. 코틀린"
    }
}
</div>

### 코드 2-29 위임된 프로퍼티 observable (observable.kt)

`kotlin.properties.Delegates.observable`을 이용하면 프로퍼티 값의 변경을 추적할 수 있다.

<div class="kotlin-playground">
import kotlin.properties.Delegates

fun main() {
    val holder = ObservableHolder()
    println("초기값: ${holder.observedValue}")
    holder.observedValue = 3
    println("변경 후: ${holder.observedValue}")
    holder.observedValue = 5
    println("변경 후: ${holder.observedValue}")
}

class ObservableHolder() {
    var observedValue by Delegates.observable(-1) { prop, old, new ->
        println("$prop: $old -> $new")
    }
}
</div>