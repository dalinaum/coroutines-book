# 2장 코틀린 기본 문법

## 2.1 엔트리 포인트

### 코드 2-1: main의 args (args.kt)

`main` 함수는 `args`인자를 받을 수 있다. 이를 활용해보자.

<div class="kotlin-playground" args="코틀린 코루틴 화이팅!">
fun main(args: Array&lt;String&gt;) {
    println("Hello World ${args[0]}")
}
</div>

자신의 컴퓨터에서 실행할 때는 args를 다음과 같이 전달해야 한다.

```sh
kotlinc args.kt -include-runtime -d args.jar
java -jar args.jar 코틀린 코루틴 파이팅
```

## 2.2 함수

### 2.2.1 반환 값이 있는 함수

#### 코드 2-2: 반환 값이 있는 함수 (increment.kt)

함수는 `fun 함수이름(파라미터 리스트): 리턴 타입` 이런 형태로 정의한다.

<div class="kotlin-playground">
fun main() {
    println(increment(3))
}

fun increment(n: Int): Int{
    return n + 1
}
</div>

### 2.2.2 단일 표현식 함수

#### 코드 2-3: 표현식 바디 (expression-body.kt)

함수의 바디는 표현식 바디(expression body)로 변경 가능하다.

<div class="kotlin-playground">
fun main() {
    println(increment(3))
}

fun increment(n: Int): Int = n + 1
</div>

#### 코드 2-4 반환 타입을 생략한 표현식 바디 (expression-body2.kt)

표현식 바디를 쓰는 경우에는 반환 타입이 추론 가능하고 생략할 수 있다.

<div class="kotlin-playground">
fun main() {
    println(increment(3))
}

fun increment(n: Int) = n + 1
</div>

### 2.2.3 여러 파라미터를 받는 함수

#### 코드 2-5 파라미터 두 개 함수 (times.kt)

여러 파라미터를 사용하는 방법은 간단하다. 파라미터 리스트에 파라미터를 여러개를 넣어보자.

<div class="kotlin-playground">
fun main() {
    println(times(3, 4))
}

fun times(a: Int, b: Int) = a * b
</div>

#### 코드 2-6 함수를 인자로 전달 (function-arg.kt)

함수를 파라미터로 쓸 때는 `(파라미터 타입들) -> 반환 값`을 타입으로 지정한다.

함수를 전달할 때는 함수 참조 `::`를 함수명 앞에 붙여준다.

<div class="kotlin-playground">
fun main() {
    println(double(6, ::times))
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}

fun times(a: Int, b: Int) = a * b
</div>

## 2.3 람다

### 코드 2-7 람다 버전의 times (lambda.kt)

람다는 중괄호 다음에 파라미터 리스트를 적고 오른쪽에 ->를 입력한다.

<div class="kotlin-playground">
fun main() {
    val times: (Int, Int) -> Int = { a, b ->
        a * b
    }
    println(double(6, times))
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}
</div>

### 코드 2-8 람다 버전의 times 2 (lambda2.kt)

람다는 중괄호 다음에 파라미터 리스트를 적고 오른쪽에 ->를 입력한다.

<div class="kotlin-playground">
fun main() {
    val times = { a: Int, b: Int ->
        a * b
    }
    println(double(6, times))
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}
</div>

### 2.3.1 고차 함수와 후행 람다

#### 코드 2-9 람다를 함수 파라미터 (lambda3.kt)

람다를 파라미터에 직접 전달하자.

<div class="kotlin-playground">
fun main() {
    println(
        double(6, { a: Int, b: Int ->
            a * b
        })
    )
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}
</div>

#### 코드 2-10 후행 람다 (trailing-lambda.kt)

마지막 파라미터가 람다인 경우 괄호 밖으로 람다를 뺼 수 있다.

<div class="kotlin-playground">
fun main() {
    println(
        double(6) { a: Int, b: Int ->
            a * b
        }
    )
}

fun double(n: Int, f: (Int, Int) -> Int): Int {
    return f(n, 2)
}
</div>

### 코드 2-11 람다를 반환 (hello-lambda.kt)

반환 값으로 람다를 리턴할 수 있다.

<div class="kotlin-playground">
fun main() {
    println(hello()("코틀린"))
}

fun hello(): (String) -> String {
    return { name ->
        "Hello $name"
    }
}
</div>

### 2.3.2 클로저

#### 코드 2-12 클로저 (closure.kt)

람다는 호출 측의 데이터를 참조할 수 있다.

<div class="kotlin-playground">
fun main() {
    println(say("안녕")("코틀린"))
}

fun say(greeting: String): (String) -> String {
    return { name ->
        "$greeting $name"
    }
}
</div>

### 2.3.3 파라미터 기본 값

#### 코드 2-13 파라미터 기본 값 (default-value.kt)

파라미터의 기본 값을 지정할 수 있다. "안녕"을 출력할 가능성이 높아 기본값으로 지정해보자.

<div class="kotlin-playground">
fun main() {
    println(say()("코틀린"))
}

fun say(greeting: String = "안녕"): (String) -> String {
    return { name ->
        "$greeting $name"
    }
}
</div>

#### 코드 2-14 파라미터를 일부만 지정 (partial-parameter.kt)

add의 파라미터 a, b는 기본 값을 가지고 있고 파라미터를 하나만 전달하면 a에 먼저 적용된다.

<div class="kotlin-playground">
fun main() {
    println(add(1))
}

fun add(a: Int = 2, b: Int = 1) = a + b
</div>

### 2.3.4 지명 인자

#### 코드 2-15 지명 인자 (named-argument.kt)

특정 파라미터를 사용하고 싶다면 호출 할 때 "파라미터 이름 = 값"의 형태로 호출한다.

<div class="kotlin-playground">
fun main() {
    println(add(b = 5))
}

fun add(a: Int = 2, b: Int = 1) = a + b
</div>

## 2.4 변수

### 코드 2-16 변수 (var.kt)

값을 변경하고 싶은 경우 var 변수를 사용한다.

<div class="kotlin-playground">
fun main() {
    var counter = 123
    counter += 1
    var one: Int = 1
    var two: Int? = 2
    println("counter: $counter, one: $one, two: $two")
}
</div>

## 2.5 클래스

### 코드 2-17 클래스 정의 (def-class.kt)

첫번째 클래스를 만들어 보자.

<div class="kotlin-playground">
fun main() {
    val porsche = Car()
    println(porsche)
}

class Car
</div>

### 코드 2-18 생성자와 프로퍼티 (constructor.kt)

클래스 이름 뒤에 파러미터 리스트를 붙이면 생성자가 된다.

클래스 생성자에서 var, val을 붙이면 해당 파라미터의 이름과 같은 프로퍼티가 만들어지고 대입된다.

<div class="kotlin-playground">

fun main() {
    val porsche = Car("Porsche")
    println("자동차의 제조사는: ${porsche.manufacturer}이다")
}

class Car(val manufacturer: String)
</div>

### 코드 2-19 바디 안의 생성자 (secondary-constructor.kt)

클래스 바디 안에 constructor 키워드로 생성자를 만들 수 있다.

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("자동차의 제조사는: ${porsche.manufacturer}이다")
}

class Car {
    constructor(manufacturer: String) {
        this.manufacturer = manufacturer
    }

    val manufacturer: String
}
</div>

### 코드 2-20 주 생성자와 부 생성자 (constructors.kt)

주 생성자와 부 생성자를 쓸 수 있다. 부 생성자는 콜론(:)뒤에 주 생성자 위임(delegation)을 넣는다.

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("제조사는 ${porsche.manufacturer}, ${porsche.cylinders}기통이다")
}

class Car(val manufacturer: String, val cylinders: Int) {
    constructor(manufacturer: String): this(manufacturer, 4) {}
}
</div>

### 코드 2-21 init 블록 (init.kt)

주 생성자가 해야할 일을 `init` 블록에 넣을 수 있다.

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("제조사는 ${porsche.manufacturer}, ${porsche.cylinders}기통이다")
}

class Car(val manufacturer: String, val cylinders: Int) {
    init {
        println("주 생성자: $manufacturer, 실린더: $cylinders")
    }
    constructor(manufacturer: String): this(manufacturer, 4) {
        println("부 생성자: $manufacturer")
    }
}
</div>

### 코드 2-22 init 없는 코드 (wo-init.kt)

`init`을 쓰지 않고 생성자도 명시적으로 바디에 넣은 코드

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("제조사는 ${porsche.manufacturer}, ${porsche.cylinders}기통이다")
}

class Car {
    val manufacturer: String
    val cylinders: Int
    constructor(manufacturer: String, cylinders: Int) {
        this.manufacturer = manufacturer
        this.cylinders = cylinders
        println("주 생성자: $manufacturer, 실린더: $cylinders")
    }
    constructor(manufacturer: String): this(manufacturer, 4) {
        println("부 생성자: $manufacturer")
    }
}
</div>

### 코드 2-23 init이 여럿인 코드 (inits.kt)

`init` 블록이 여럿일 수 있다.

주 생성자가 불러질 때 `init`이 순서대로 여럿 호출된다.

<div class="kotlin-playground">
fun main() {
    val porsche = Car("Porsche")
    println("제조사는 ${porsche.manufacturer}, ${porsche.cylinders}기통이다")
}

class Car(val manufacturer: String, val cylinders: Int) {
    init {
        println("첫 번째 init: $manufacturer, 실린더: $cylinders")
    }
    constructor(manufacturer: String): this(manufacturer, 4) {
        println("부 생성자: $manufacturer")
    }
    init {
        println("두 번째 init: $manufacturer, 실린더: $cylinders")
    }
}
</div>

## 2.6 프로퍼티

### 코드 2-24 간단한 프로퍼티 (property.kt)

클래스 내에서 변수를 선언하듯 간단히 프로퍼티를 만들 수 있다.

`counter`라는 프로퍼티를 만들었다.

<div class="kotlin-playground">
fun main() {
    val holder = CounteHolder()
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
}

class CounteHolder() {
    var counter = 0
}
</div>

### 코드 2-25 프로퍼티 세터 (propoerty-setter.kt)

`set(value)`로 프로퍼티에 세터를 설정할 수 있다. 게터는 자동으로 생성된 것을 사용한다.

<div class="kotlin-playground">
fun main() {
    val holder = CounteHolder()
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
}

class CounteHolder() {
    var counter = 0
        set(value) {
            field = value * 2
        }
}
</div>

### 코드 2-26 프로퍼티 게터 (property-getter.kt)

`get()`로 프로퍼티에 게터를 설정할 수 있다. 세터는 자동으로 생성된 것을 사용한다.

<div class="kotlin-playground">
fun main() {
    val holder = CounteHolder()
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
    holder.counter++
    println("카운터: ${holder.counter}")
}

class CounteHolder() {
    var counter = 0
        get() {
           return field + 1  
        }
}
</div>

### 코드 2-27 뒷받침하는 프로퍼티 (backing-property.kt)

프로퍼티가 직접 필드를 가지지 않고 다른 프로퍼티에 의존하는 방법이다.

`list` 프로퍼티가 `var`인 경우에는 세터까지 설정해야 한다.

<div class="kotlin-playground">
fun main() {
    val holder = ListHolder()
    println("list: ${holder.list}")
    holder.addItem("Kotlin")
    println("list: ${holder.list}")
}

class ListHolder() {
    private var _list: MutableList&lt;String&gt;? = null

    val list: List&lt;String&gt;
        get() {
           if (_list == null) {
                _list = mutableListOf("Hello", "World")
           }
           return _list ?: throw AssertionError("다른 스레드가 변경하였습니다")
        }

    fun addItem(item: String) {
        _list?.add(item)
    }
}
</div>

### 코드 2-28 위임된 프로퍼티 lazy (lazy.kt)

`lazy`를 이용해 위임하면 늦게 초기화를 할 수 있음.

<div class="kotlin-playground">
fun main() {
    println("계산 전")
    val holder = LazyHolder()
    println("계산된 결과: ${holder.computedValue}")
    println("첫 번째 리턴")
    println("계산된 결과: ${holder.computedValue}")
    println("두 번째 리턴")
}

class LazyHolder() {
    val computedValue by lazy {
        println("열심히 계산 중!")
        "안녕하세요. 코틀린"
    }
}
</div>

### 코드 2-29 위임된 프로퍼티 observable (observable.kt)

`kotlin.properties.Delegates.observable`을 이용하면 프로퍼티 값의 변경을 추적할 수 있다.

<div class="kotlin-playground">
import kotlin.properties.Delegates

fun main() {
    val holder = ObservableHolder()
    println("초기값: ${holder.observedValue}")
    holder.observedValue = 3
    println("변경 후: ${holder.observedValue}")
    holder.observedValue = 5
    println("변경 후: ${holder.observedValue}")
}

class ObservableHolder() {
    var observedValue by Delegates.observable(-1) { prop, old, new ->
        println("$prop: $old -> $new")
    }
}
</div>

### 코드 2-30 다른 프로퍼티로 위임 (delegate-to-other.kt)

다른 프로퍼티로 위임할 수 있다. `@Deprecated` 등에 사용 가능.

<div class="kotlin-playground">
fun main() {
    val holder = Holder()
    println("newName: ${holder.newName}")
    println("newName: ${holder.oldName}")
    holder.newName = "코루틴"
    println("newName: ${holder.newName}")
    println("newName: ${holder.oldName}")
}

class Holder() {
    var newName = "코틀린"

    @Deprecated("Use newName instead")
    var oldName by this::newName
}
</div>

### 코드 2-31 커스텀 위임된 프로퍼티 (custom-delegated-property.kt)

Delegate를 직접 만들 수 있다. 구현해야하는 메서드는 `getValue`와 `setValue`다.

 * `operator fun getValue(thisRef: Any?, property: KProperty<*>): TYPE`
 * `operator fun setValue(thisRef: Any?, property: KProperty<*>, value: TYPE)`

<div class="kotlin-playground">
import kotlin.reflect.KProperty

fun main() {
    val holder = Holder()
    println("name: ${holder.name}")
    holder.name = "코루틴"
    println("name: ${holder.name}")
    holder.name = "코틀린"
    println("name: ${holder.name}")

    println("manufacturer: ${holder.manufacturer}")
    holder.manufacturer = "순양"
    println("manufacturer: ${holder.manufacturer}")
    holder.manufacturer = "대현"
    println("manufacturer: ${holder.manufacturer}")
}

class CustomDelegate {
    val map = mutableMapOf<String, String>()

    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        println("$thisRef, '${property.name}' 프로피터를 위임했습니다.")
        return map[property.name] ?: "비어있습니다."
    }

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) {
        println("${thisRef}의 ${property.name}에 ${value}를 대입합니다.")
        map[property.name] = value
    }
}

class Holder() {
    val customDelegate = CustomDelegate()
    var name by customDelegate
    var manufacturer by customDelegate
}
</div>

## 2.7 Unit 리턴 함수

### 코드 2-32 Unit 리턴 함수 (unit-returning-function.kt)

반환 값이 없는 경우 타입은 `Unit`이다.

<div class="kotlin-playground">
fun main() {
    val greeter = Greeter()
    greeter.sayHello()
}

class Greeter() {
    fun sayHello(): Unit {
        println("안녕하세요!")
    }
}
</div>

## 2.8 가변 인자 함수

### 코드 2-33 가변 인자 (vararg.kt)

인자의 갯수를 한정할 수 없는 경우 `vararg`를 사용하자.

<div class="kotlin-playground">
fun main() {
    val names = makeNameList("카리나", "지젤", "닝닝", "윈터")
    println(names)
}

fun makeNameList(vararg names: String): List&lt;String&gt; {
    val list = mutableListOf&lt;String&gt;()
    for (name in names) {
        list.add(name)
    }
    return list
}
</div>

## 2.9 확장 함수

### 코드 2-34 확장 함수 getCapitalizedItem (capitalized-item.kt)

확장 함수를 이용하면 기존 클래스의 기능을 확장할 수 있다. `MutalbeList`에 `getCapitalizedItem`이란 확장 함수를 추가해보자.

<div class="kotlin-playground">
fun main() {
    val names = mutableListOf("karina", "giselle", "ningning", "winter")
    println(names.getCapitalizedItem(0))
    println(names.getCapitalizedItem(1))
}

fun MutableList&lt;String&gt;.getCapitalizedItem(index: Int): String {
    return get(index).capitalize()
}
</div>

### 코드 2-35 확장함수 swap (swap.kt)

제너릭한 확장 함수를 만들어보자. `getCapitalizedItem`은 String의 리스트에서만 사용할 수 있었다. 반면 `swap`은 아무 타입의 리스트 MutableList에 대해 사용할 수 있다.

<div class="kotlin-playground">
fun main() {
    val names = mutableListOf("karina", "giselle", "ningning", "winter")
    names.swap(1, 2)
    println(names)
}

fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) {
    val temp = this[index1]
    this[index1] = this[index2]
    this[index2] = temp
}
</div>

## 2.10 중위 함수

### 코드 2-36 infix (infix.kt)

`infix` 키워드가 붙이면 중위 표기를 할 수 있다. 호출에서 점(.)을 생략하고 괄호를 생략할 수 있다.

<div class="kotlin-playground">
fun main() {
    println("123" plus "456")
}

infix fun String.plus(number2: String): String {
    return "${this.toInt() + number2.toInt()}"
}
</div>

### 코드 2-37 infix 멤버 함수 (member-fun-infix.kt)

`infix`는 멤버 함수에서도 사용할 수 있다.

`A plus B`, `A.plus(B)`의 호출은 가능하지만 `plus B`의 형태로는 호출할 수 없다.

<div class="kotlin-playground">
fun main() {
    val a = Nice("123")
    println(a plus "456")
    a.doSomething()
}

class Nice(var something: String) {
    infix fun plus(other: String): String {
        return "${something.toInt() + other.toInt()}"
    }

    fun doSomething(): String {
        return this plus "123" // OK
        // return this.plus("123") // OK
        // return plus "123" // NG
    }
}
</div>

## 2.11 수신 객체 지정 람다

### 코드 2-38 수신객체와 람다 (lambda-with-receiver.kt)

람다를 만들 때 파라미터 리스트 앞에 타입을 붙일 수 있다.

```
타입.(파라미터 리스트)
```
수신 객체 지정 람다는 마치 자신이 타입인양 동작한다. 이 타입을 수신 객체(Reciever)라고 부른다.

수신 객체 지정 람다에서는 (당연히) 파라미터도 사용할 수 있다.

<div class="kotlin-playground">
fun main() {

    val lambdaWithReceiver: String.() -> Unit = {
        println("length: $length")
        println("content: $this")
        println("capitalized: ${capitalize()}")
    }
    "nice".lambdaWithReceiver()
    lambdaWithReceiver("ultra")
}
</div>

### 2.11.1 범위 지정 함수 let

#### 코드 2-39 범위 지정 함수 let (let.kt)

`let`은 수신 객체 T를 확장한 함수로 람다의 파라미터 타입은 T이며 람다의 반환 값을 리턴한다.

<div class="kotlin-playground">
fun main() {
    Person("홍길동", 20, "한양").let { hong ->
        println(hong)
        hong.moveTo("율도국")
        hong.incrementAge()
        println(hong)
    }
}

data class Person(var name: String, var age: Int, var city: String) {
    fun moveTo(newCity: String) { city = newCity }
    fun incrementAge() { age++ }
}
</div>

#### 코드 2-40 범위 지정 함수 let과 it (let-with-it.kt)

파라미터가 1개인 람다는 파라미터 명을 생략할 수 있다. 이 경우 파라미터는 `it`이 된다.

<div class="kotlin-playground">
fun main() {
    Person("홍길동", 20, "한양").let {
        println(it)
        it.moveTo("율도국")
        it.incrementAge()
        println(it)
    }
}

data class Person(var name: String, var age: Int, var city: String) {
    fun moveTo(newCity: String) { city = newCity }
    fun incrementAge() { age++ }
}
</div>

#### 코드 2-41 let의 반환 값 사용 (let-returns.kt)

let 람다의 마지막 값의 타입으로 리턴이 된다.

<div class="kotlin-playground">
fun main() {
    val name = Person("홍길동", 20, "한양").let {
        println(it)
        it.moveTo("율도국")
        it.incrementAge()
        println(it)
        it.name
    }
    println("name: $name")
}

data class Person(var name: String, var age: Int, var city: String) {
    fun moveTo(newCity: String) { city = newCity }
    fun incrementAge() { age++ }
}
</div>

#### 코드 2-42 let과 Nullable (let-with-nullable.kt)

let 람다의 마지막 값의 타입으로 리턴이 된다.

<div class="kotlin-playground">
fun main() {
    var person: Person? = Person("홍길동", 20, "한양")
    person?.let { person ->
        println(person)
        person.moveTo("율도국")
        person.incrementAge()
        println(person)
    }
}

data class Person(var name: String, var age: Int, var city: String) {
    fun moveTo(newCity: String) { city = newCity }
    fun incrementAge() { age++ }
}
</div>

### 2.11.2 범위 지정 함수 with

#### 코드 2-43 범위 지정 함수 with (with.kt)

with는 수신 객체를 첫 번째 인자, 후행 람다를 두 번째 인자로 받고 람다의 반환 값을 리턴한다.

<div class="kotlin-playground">
fun main() {
    val name = with(Person("홍길동", 20, "한양")) {
        println(this)
        moveTo("율도국")
        incrementAge()
        println(this)
        name
    }
    println(name)
}

data class Person(var name: String, var age: Int, var city: String) {
    fun moveTo(newCity: String) { city = newCity }
    fun incrementAge() { age++ }
}
</div>